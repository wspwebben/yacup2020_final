# F. Оптимизация товарных модулей (60 баллов)

Жизнь космического торговца очень проста: освобождаешь грузовой отсек своего корабля, чтобы погрузить новые торговые модули. Что находится внутри торговых модулей, разбираться некогда, да и слишком сложно это для простого торговца. Торговцы точно знают лишь то, что внутри модуля лежат «единицы экспорта», которые можно продать заинтересовавшимся. 

Глава торговой космической гильдии стал замечать, что внутри торгового модуля остается всё больше и больше «единиц экспорта», которые никому не пригодились, а значит, и не принесли прибыли. 

Торговцы решили сделать следующую систему: 
- покупатели формируют единый заказ на конкретные "единицы экспорта"из торговых модулей. Такой заказ называется "входной заявкой"; 
- "входных заявок"может быть несколько;

Для описания заявки был выбрал Javascript и ES6 система модулей. Пример торговой заявки:

```
import {a, b} from ’./modules/module_a.js’;  
import {c as k, d} from ’./modules/module_b.js’;
```

Глава хочет найти инженера, способного разобраться во внутреннем устройстве товарных модулей. Инжинеру придётся наладить процесс отсеивания "единиц экспорта"из модулей по данным из "входной заявки"до того, как улетит торговый корабль.

## Формат ввода

Несколько инженеров подступались к задаче, но так и не смогли ее решить. Вот какие выводы они сделали: 
- из торгового модуля нив коем случае нельзя убирать «единицу экспорт», которая необходима кому-либо в заявке ; 
- «единицы экспорта» внутри одного торгового модуля могут быть связаны так, что, убрав одну единицу, модуль обесценивается; 
- внутри модуля могут быть переиспользованы «единицы экспорта» из других модулей, однако циклических зависимостей нет; 
- гарантируется, что торговые модули состоят только из «единиц экспорта», все единицы именованы, а их имя уникально в рамках одного модуля; 
- "единица экспорта"может представлять из себя: констату, функцию, объект, массив, строку, шаблонную строку.

Опираясь на выводы инженеров, вам необходимо разработать технологию, позволяющую максимально облегчать торговые модули, не обесценивая их.

Необходимо реализовать функцию, принимающую на вход: Информацию о заявках, в формате объекта, где: 
- ключ - абсолютный путь до модуля от корня, 
- значение - строковое представление кода, Второй аргумент функции - массив с абсолютными путями до "входных заявок"торговцев.

В результате выполнения функции исходный код должен измениться таким образом, что остаться должны только используемые экспорты. Менять при этом аргументы **import** и **делать полный dead code elimination** в исходном коде не требуется. Главное - удалить неиспользуемые единицы экспорта.

Пример: Первый аргумент.
```
{  
  "/root/omegaTradersCluster/firstTrader.js":  
    "export const first = () => 12;\n\nexport const second = {a: 12};\n",  
  "/root/entrypoint.js":  
    "import {first} from \"./omegaTradersCluster/firstTrader.js\";\n\"  
}
```

Второй аргумент.
`["/root/entrypoint.js"]`

Заметим, что **second** не был использован и его код может быть удален.

## Формат вывода

Ответ:
```
{  
  "/root/omegaTradersCluster/firstTrader.js":  
        "export const first = () => 12;\n",  
  "/root/entrypoint.js":  
        "import { first } from \"./omegaTradersCluster/firstTrader.js\";\n\"  
}
```

Для быстрого освоение со структорой AST, рекомендуется использовать [интерактивный сайт](https://astexplorer.net/#/gist/483d99247e5113d26017ec5426699913/e39116ec906cf2e887a8820b31688e74f9832935)

## Примечания
Файл с решением оформите по шаблону::

```
// обязательно используйте этот парсер для построения дерева  
const parser = require(’@babel/parser’);  
// для обхода дерева можете использовать данную библиотеку  
// или написать свой обход  
// подробнее тут: https://babeljs.io/docs/en/babel-traverse  
const traverse = require(’@babel/traverse’).default;  
// обязательно используйте генератор для формирования ответа  
const generate = require(’@babel/generator’).default;  
 
module.exports = function (filesInfo, entrypoints) {  
    const result = {};  
 
    for (const [filePath, fileText] of Object.entries(filesInfo)) {  
        // подробнее https://babeljs.io/docs/en/babel-parser  
        // однако дополнительных опций не требуется  
        const ast = parser.parse(fileText, {  
            sourceType: ’module’,  
        });  
 
        // какие-то манипуляции с деревом исходного файла  
 
        // генерируем новый код из дерева, не добавляйте дополнительных опций  
        // подробнее https://babeljs.io/docs/en/babel-generator  
        const new_code = generate(ast).code;  
 
        result[filePath] = new_code;  
    }  
 
    return result;  
}
```
